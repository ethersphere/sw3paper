
\section{Swap channels}

One of the major issues with direct ``on-chain'' payments in a blockchain network, is that each transaction must be processed by each and every node participating in the network, resulting in high transaction costs.
One strategy to mitigate transaction costs is to defer payments and process them in bulk. In exchange for reduced cost, the beneficiary must be willing to incur higher risk of settlement failure.

\subsection{A simple chequebook}\label{subsec:simple-chequebook}

A very simple smart contract that allows the beneficiary to choose when payments are to be processed, was introduced in \cite{ethersphere2016sw3}.
This \gloss{chequebook} contract is a wallet that can process cheques issued by its owner. The cheques are
analogous to those in the real-world: the issuer signs a cheque specifying a beneficiary, a date and an amount,
gives it to the recipient as a token of promise to pay at a later date. The smart contract plays the
role of the bank. When the recipient wishes to get paid, they ``cash the cheque'' by submitting it to the smart contract. The contract, after validating the signature, date and the amount specified on the cheque, transfers the amount to the beneficiary's account (see figure \ref{fig:swap-chequebook}).
%Analogously to the person taking the cheque to the bank to cash it, anyone can send the digital cheque as part of the data in a transaction to the owner's chequebook account and thus trigger the transfer.

\input{swap-diagram.tex}

Since these digital cheques are files and can therefore be copied, care must be taken that the same cheque cannot be cashed twice. Such ``double cashing'' can be prevented by assigning each cheque given to a particular beneficiary a serial number which the contract will store when the cheque is cashed. The chequebook contract can then rely on the serial number to make sure cheques are cashed in sequential order, thus needing to store only a single serial number per beneficiary.
An alternative strategy to prevent double cashing, when repeated payments are made to the same beneficiary, is that the cheques contain the \emph{cumulative} total amount ever credited to the beneficiary. The total cumulative amount that has been cashed out is stored in the contract for each beneficiary. When a new cheque is submitted, the contract ignores cheques with amount equal to or less than the stored total, but it will transfer the difference if it receives a cheque with a higher total.

This simple trick also makes it possible to cash cheques in bulk because only the current `last cheque' need ever be processed. This achieves the reduction of transaction costs alluded to above.

Incidentally, the cumulative amount stored in the contract represents the total of all outgoing payments that have been honoured and thus the contract also serves as a credit history for the owner.

The amount deposited in the chequebook (\gloss{global balance}) serves as collateral for the cheques. It is pooled over the beneficiaries of all outstanding cheques.
In this simplest form, the chequebook has the same guarantee as real-world cheques: none. Since funds can be freely moved out of the chequebook wallet at any time, solvency at the time of cashing can never be guaranteed: if the chequebook's balance is less than the amount sanctioned by a cheque submitted to it, the cheque will bounce. This is the trade off between transaction costs and risk of settlement failure.

\input{swap-cheques.tex}

\input{swap-waivers.tex}

\subsection{Channel deposits}

\subsubsection{Using the chequebook as one half of a payment channel}
The prototypical payment channel consists of a smart contract set up by two parties A and B. The contract has some number of ether locked up in it that A and B have deposited and the contract keeps track of which portion of the locked up ether belongs to each party. The two parties A and B can exchange signed messages that would (if submitted to the channel contract) change the balance of ownership. Many such messages can be sent back and forth and function as payments between the two parties. Crucially, most of these messages do not need to be submitted to the contract at all. Parties may submit a new state to the channel at any time in order to `save the current state on-chain', but only when one party wishes to actually withdraw ether from the channel does the last message indicating the current `state' of the channel - i.e. the balance between A and B - \emph{have} to be submitted.

A chequebook contract implementing a debt waiving procedure like the one outlined in section \ref{subsubsec:waivingdebt} shares a lot of the same features. If user A has deployed such a chequebook and is using it to pay user B, then the cheques act very similarly to the payment messages above. Key differences to a full payment channel are

\begin{enumerate}
    \item Initially payments can only flow in one direction (from A to B) and the balance can never go `below zero` i.e. in A's favour. This is why we refer to this construct as `half' of a payment channel. It is analogous to a payment channel in which the initial deposit was made only by A.
    \item Balances cannot be updated on-chain without a transfer. All collateral in the contract belongs to A; all that B can do is send in cheques to request a payout.% and then subsequently send the received funds to her own chequebook contract.
    \item Payout is not guaranteed. 
\end{enumerate}

The fact that payout is not guaranteed is a result of the fact that cheques can bounce (see section \ref{subsec:simple-chequebook}). However it is possible to add a payout guarantee to the cheques on a per-user basis.

\subsubsection{Per-user guarantees}\label{subsubsec:per-user-guarantees}

The chequebook deployed by user A has a balance of ether that acts as collateral for all outstanding cheques A has issued. As such, any user B holding a cheque from A has no guarantee that payout will be possible at any particular time in the future. 

To add a payout guarantee, we need to make only small modifications to the contract. Explicitly, in order to be able to issue guaranteed cheques to user B, the contract would contain some ether that is locked in the contract and acts as collateral for payments from A to B only. Any cheques held by B are thus guaranteed to be honoured up to this locked amount. Indeed, the only way A can withdraw the locked amount would involve a payout request by A followed by a grace period during which B is still able to submit any outstanding cheques.

With this mechanism in place, the chequebook is now almost equivalent to a full payment channel (albeit one in which the entire initial deposit was made by A).

Note: If both A and B have such a chequebook contract, each having some collateral locked up for the other, then this setup is functionally equivalent to a full payment channel; with the exception that states can not be `saved on-chain' without an actual transfer. In a real payment channel the contract can update the relative balance - how much of the tied up collateral belongs to A and how much belongs to B - but in the chequebook implementation such a re-balancing necessarily involves a transfer from one chequebook contract to the other.%
%
\footnote{To be clear, the equivalent action of updating the channel state on-chain is possible, but more expensive, possibly substantially so. It would involve B cashing A's cheques then sending those funds to her own chequebook contract as collateral and then increasing the funds locked up with A as the beneficiary by that amount.} 
%
This is discussed in detail in the remainder of this section.
Furthermore, advanced payment channels such as Raiden \cite{citation-needed:Raiden} have the ability to string together individual channels and compose them into a network. This method is picked up in section \ref{sec:networks}.

Nevertheless, the chequebook implementation has the advantage that it can start out simple with features being added gradually as they are needed.

\subsubsection{Hard channel deposit}

First we introduce the notion of \gloss{hard channel deposit}, a part of the global deposit that is always dedicated to a channel. The sum of all channel deposits is the total channel deposit. The global balance must not be less than the total of channel deposits. Channel deposit allocations can be controlled via transactions. Whenever a part of A's balance is assigned to B, the balance is checked and the transaction fails if total  channel deposits would exceed the global balance.

Conversely, when the owner attempts to withdraw from the swap contract, the balance is not allowed to go below the total of channel deposits. For ease of explanation assume that the contract keeps track of the current sum of channel deposits, and saves it as \gloss{global deposit}. The difference between the global balance and global deposit is the \gloss{liquid balance}. The total of channel deposits is never higher than the global deposit, the difference is \gloss{global liquid deposit} (see figure \ref{fig:softchanneldeposit}).

\begin{center}
\begin{figure}
\begin{center}
\begin{tikzpicture}
\end{tikzpicture}
\end{center}
\caption{Swap balances and deposits}
\label{fig:softchanneldeposit}
\end{figure}
\end{center}


The idea is to distribute this global liquid deposit among the swap channels in a cost-effective, flexible yet secure way.%
%
\footnote{The global deposit can be implemented by the channel deposit assigned to the owner. Two step delayed withdrawal would fall out from this construct.}
%
At any point in time insolvency can be triggered if total uncashed balance is not covered by the global balance: $\sum_{i\in P}u_i > b$. On the other hand, solvency is guaranteed to a peer B if the total of outstanding uncashed cheques from A to B is not greater than the total channel deposit ($u_B <= d_B$). If it is greater ($u_B > d_B$), part of A's liability is unsecured: $l_B = u_B - d_B$. If solvency is not guaranteed, it is reasonable for peer B to cash their cheque. If all peers do this, there is a bank run. If the sum of overruns is not greater than the liquid balance ($\sum_{i\in P}l_i <= l$, the bank run ends well, otherwise the creditors compete for 
liquidating their entitlement before the liquid balance runs dry.
Insolvency is known if there is a peer whose unsecured uncashed balance is higher than the global liquid balance, i.e., $l_B > l$.
Solvency is not guaranteed if $u_B > d_B$, and as $u_B$ increases, so does the potential loss in case of insolvency. Is it possible to secure allocations of the liquid deposit so that it tracks the liabilities? 

\subsubsection{Soft channel deposit}

In the following we describe a construct which gives 100$\%$ guarantee of solvency on the outstanding liabilities of peer A without explicitly assigning deposits to channels on chain.%
%
\footnote{In the on-chain case channel deposits are explicitly stored in the contract, therefore overspending
(using the amount to collateralise multiple creditors) is impossible.}

Assume that there exist a notion of \gloss{epoch},
a fixed settlement period at the end of which B needs to sign off on the total sum of outstanding liability implied in the uncashed cheques issued by A to B.
Each time A sends a cheque to B they can offer to reallocate some of the liquid deposit to B, this is a \gloss{soft channel deposit offer}. 
Formally, a \gloss{soft channel deposit note} is a signed note with the following fields:

\begin{itemize}
  \item address
  \item the epoch index
  \item serial number
  \item soft channel deposit claim
\end{itemize}

If the address is the address of the creditor, then the debtor needs to sign it, then the note is an offer. 
If the address is the debtors address, it is signed by the creditor it is a claim. As A is sending cheques to B, it can continually attach a channel deposit offer.

For ease of explanation let us assume the allocated soft channel deposit to B is zero, and A sends a cheque to B in the amount of X then it attaches with an offer to raise the allocation from zero to X. 
B can evaluate that offer and sign off on the claim. 
As long as cheques received do not go over the  hard channel deposit, solvency of A to B's claims is guaranteed. It depends on how risk averse B is, to suggest when it would like to settle on the allocations. If the epoch does not end before B considers taking on more debt from A, they just stop providing service. 

The soft channel deposit claim is the amount B would like to see secured/dedicated to them exclusively.
Assume that at the end of the epoch A's every  active peer has sent at least one claim to A.
After A receives soft channel deposit claims from all its active peers for the epoch, the claims are
collected in a list (ordered according to the peer index of the beneficiary in A's swap contract).
A signs the swarm hash of the (concatenated) list and sends it alongside the list to each peer
in a construct called a \gloss{soft channel deposit allocation table}.

Upon receiving the soft channel deposit allocation table, B verifies that
(1) the total sum of channel deposits allocated is no greater than the global deposit and
(2) the amount dedicated to B is no less than the total uncashed balance on matured cheques issued by A to B.
(3) each active peer in A's swap contract has a corresponding claim for the current epoch and the signature is valid.
This process in illustrated in figure \ref{fig:softchanneldeposit}



\begin{center}
\begin{figure}
\begin{center}
\begin{tikzpicture}
\end{tikzpicture}
\end{center}
\caption{Hard and soft channel deposit}
\label{fig:softchanneldeposit}
\end{figure}
\end{center}


If the soft channel deposit allocation table is valid,
we can with complete certainty know that the global deposit in A's contract
 could cover all outstanding cheque handed to B even if all peers were to redeem all of their outstanding notes (e.g., by satisfying A's conditional bond).
Practically this means then that, after receiving a valid allocation table for the epoch from A,
B has no risk of insolvency when dealing with A. 

What if we consider holding out as a service, we can conceive of A and B exchanging cheques and soft channel deposit offers  and claims. This is analogous to the underlying service tit-for-tat accounting. In a way, hard channel deposits play the role of the payment  threshold in simple swap, whereas soft channel deposit offers and claims are somewhat analogous to cheques or waivers.
Instead of the dynamic swap cycle of the simple swap, here the cycle corresponds to an epoch. This effectively makes the hard channel deposit a throughput restriction on the channel traffic. Conversely, the hard channel deposit should  be chosen to allow for the maximum desired throughput over an epoch. 

We can define a strict etiquette for the protocol. The moment uncashed cheques goes above zero, soft channel deposit offer should cover it. If it goes above the total channel deposit, the peer stops providing service until the next epoch, when reallocation of soft channel deposit can bring the higher level swap balance back to zero.

This strict protocol has far-reaching consequences: Firstly, dropped (or censored or otherwise impeded) peers cannot lose anything, even if their new claim is not included in the new allocation table because the amount of increase in withheld cheques is within the limit of the hard channel deposit. 
If we make the soft channel deposit claim contain the last serial number and swap balance, submitting the inclusion proof of the B's soft channel deposit claim in a valid current allocation table is sufficient to immediately release funds. 
Another important consequence of the strict protocol that at any one time only one of two connected peers is sending an allocation table to the other. The recipient can use the received one as evidence that the peer claim is zero.

So far we just assumed that all peers can give a valid claim at the end of the epoch. 
If there is no absolute consensus on who participates, 
peers could be given alternative allocations by A. Two groups of nodes would be made to believe they are the unique descendent of the original group. The allocation table signs off on the active participants.
If peers can just be dropped a malicious node can start issuing alternative allocation tables to two sets of peers. Colluding adversaries in both groups would sign off on reduced allocations which then can be used to cover the increased allocations in both groups. If the victims accept their allocation table valid (assuming exhaustivity), they can be exploited with such a continuous double spend as long as they delay going to the blockchain to settle. To mitigate this attack, one has to make sure that the active peer set does not split. While it would be possible for peers to agree on the allocation in a multiparty state channel with unanimous consensus rule but this suffers from the same availability issue as what it is trying to solve.

We propose instead that it is A's responsibility to prove off-chain that they issue a single allocation table. 
Adding new peers to the allocation table is always possible, so is increasing the channel deposits unilaterally. 
If we can make sure that A issues a unique resource update for the active set in every epoch, then dropping nodes are not a problem. 
We can assume that if C formerly part of a group presented with the alternative table, they start retrieving the update and verify it. 

A protocol called \gloss{mutable resource update notifications} offers a solution: 
the pull notification version requires the resource owner to send a resource update chunk to a number of 
deterministic but not predictable addresses. These are stored and served exactly as chunks. 
When B and C are in their respective split, then both B and C check resource updates at the same time. An adversary A has a hard time making sure that each of the two versions is served to the respective peer that expects it. Due to sender anonymity in retrieval requests cannot easily be linked to the identity, although direction where the request is coming from can be .
This uses the power of the big network to make it impossible for adversaries to fork on the truth.
%https://gist.github.com/zelig/895563df3357ef862f30be5c4344e63f

In summary, using soft channel deposits enables the chequebook owner to allocate and reallocate funds
as channel deposits in a fairly flexible way without blockchain transaction costs,
yet provide $100\%$ solvency guarantees on all active conditional bonds and bounties to their peers.




% \textbf{Suggestion: delete the rest of this subsection}
% 
% 
% If the variance is expected to be higher than the loss a peer can afford,
% risk of insolvency can be mitigated by assigning part of the balance to a beneficiary.
% This locked up sum, called \gloss{channel deposit} allows the owner a tilted balance and
% serves as assured collateral dedicated to a particular peer.
% This can be implemented by keeping peer-specific balances in the chequebook contract.
% This deposit is no longer pooled over multiple creditors
% and locking it can guarantee successful cashing of cheques up to the deposited amount.
% Withdrawal from the channel deposit is possible but involves a grace period during which
% the counterparty is invited to challenge the current balance by sending in the (last) cheque
% with the highest amount. After the grace period the owner can reduce the deposit to cover only
% its actual debt and may withdraw the remainder.
% In order to get the balance of account between peers, the contract needs access to the counterparty
% chequebook contract. For ease of explanation we assume that beneficiary is the
% chequebook contract itself. Channel deposits can then be implemented as a map with beneficiary contract
% address as key and the integer balance in wei as value.
% /

\subsection{Zero barrier to entry}

A tremendous advantage of swap accounting is  y.

Swap accounting can also work in one direction only. If a party enters the system with zero ether (\gloss{newcomer}), but connects to peers with funds (\gloss{insider}), the newcomer begins to provide the service (and not use it) in order to earn a positive swap balance. Once the payment threshold is reached, the newcomer will be paid and is then able to deploy chequebook of her own.
In short, even without any chequebook contract at all, Swap allows for zero cost onboarding of newcomers. Once the payout threshold is reached, the insiders could pay the newcomers on-chain. 

If the insider has a chequebook and wishes to pay the newcomer with a cheque, this is also possible, but there is a caveat here in that cashing cheques requires a gas expenditure.%
%
\footnote{although this restriction may fall once ethereum is upgraded to the `Metropolis' release in which the chequebook contract will be able to pay for the transfer and deduct the cost of the transfer from the payout.}
%
The newcomer will be able to earn cheques for services provided, but will not have the means to cash them. 
Unless the first transaction is on-chain or the node can convince one of its peers to send the transaction for them.
We allow nodes to sign off on a structure, and extend the swap contract with a preprocessing step, which 
triggers payment to the transaction sender covering the transaction's gas cost plus a service fee. 
  
A newcomer connects to  an insider with an existing chequebook contract. The insider consumes the newcomers services and instead of issuing a cheque, the insider agrees to create a chequebook contract for the newcomer. In other words, when the insider's service debt reaches the amount needed for contract creation, the insider sends a transaction to create the contract with newcomer as the owner. Once the newcomer has her own chequebook contract, she is able to consume services and issue cheques to pay for them.
 
In order to be useful however, the deployed chequebook must also have some positive balance as collateral. Since the newcomer has no ether, it must be the insiders who deposit this starting balance. If peers agreed that they want to save on transaction costs, it is reasonable to create the contract with the required initial balance in one go. This would imply waiting out with contract creation until the insider's debt reaches the \emph{cost of bootstrapping} which is the sum of (1) the cost of contract creation, (2) the required starting balance, and (3) possibly some extra service fee to incentivise insiders to provide this kind of service.

\begin{center}
\begin{figure}
\begin{center}
\end{center}
\caption{Bootstrapping or how to launch as a swap capable node consuming and providing a
service  and earn money}
\label{fig:bootstrapping}
\end{figure}
\end{center}


To summarise, by serving before consuming, participants can bootstrap their way into swap without the need for funds. Hence swap is justified as (\emph{setting up a wallet as payment}).
