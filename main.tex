\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{verbatim}
\usepackage{multirow}
\usepackage{csquotes}
\usepackage{tikz}
\usetikzlibrary{arrows, arrows.meta, fit,positioning,shapes,automata}
\usepackage{fancyhdr}
\usepackage[titletoc,title]{appendix}
\usepackage[hidelinks]{hyperref}%
\usepackage[section,numberedsection, acronym, toc]{glossaries}
%\newacronym{grant}{GRANT}{Global Resource Allocation via Network Topology}
\makeglossaries
\bibliographystyle{apalike}

\input{glossary.tex}

\newcommand\gloss[1]{\emph{\gls{#1}}}


\title{Generalised swap swear and swindle games}
% \subtitle{Scalable infrastructure for decentralised service economies}
\author{Viktor TrÃ³n, Aron Fischer}
\date{\today}
\begin{document}


\maketitle
\begin{abstract}
\end{abstract}

\tableofcontents

\input{introduction.tex}

\input{swap.tex}


\section{Escrow conditions on future payments}

\gloss{Promissory notes} represent redeemable promises of payment potentially maturing in the future.
We define the general notion of a note as a promise that entitles a beneficiary to future payment
under a condition. Since this effectively puts the money in an escrow, the condition can
also be referred to as an \gloss{escrow condition}.
A promissory note can contain the following optional fields:

  \begin{itemize}
    \item swap cycle index
    \item amount
    \item beneficiary
    \item escrow address
    \item valid from
    \item valid until
    \item remark
  \end{itemize}

In the simplest case no escrow condition or maturation date is given: such a note
represents a simple cheque as discussed above.
The maturation date (blockheight or timestamp) can be specified to indicate the earliest
possible occasion a note can be redeemed (valid from) as well as a deadline when the promise
expires unless its escrow condition is satisfied (valid until).

\subsection{Recurring payments}

The cheque represents an adhoc promise to redeem an amount.
The transfer of funds is sanctioned by a cheque issued for each occasion.
There is, however, services where recurring payments are predictable and therefore
the installments can be sanctioned in advance. The primary usecase is subscription
services.
This could be implemented by storing a whitelist of contract addresses that are allowed
to withdraw from the chequebook balance.
For simplicity, however, we choose to represent this analogously to cashing a cheque.
Authorising a recurring payment to a contract is done by signing a blank cheque (a cheque with
an unspecified amount) against the beneficiary possibly with a valid until date.
Such beneficiaries are smart contracts and therefore no defense against
false amount is needed.
Receiving transfer request transactions is independent of the swap state of cumulative amount
and simply withdraws the amount from the global balance or the channel deposit of the owner.

\subsection{Bonds}

A note with an amount and beneficiary and a future valid from data is effectively a bond.
The amount factors in all outstanding payment obligations the beneficiary is entitled to
once the bond matures including interest. When such a note is not collateralised at the time of issuing,
accepting the bond is equivalent to granting a loan on the grounds of the credit history of the account.

\subsection{Escrow conditions and escrow witnesses}

If an escrow address is specified in the note, the referenced contract can be used to verify the condition
of redemption. When the escrow condition is verified, the owner, the beneficiary address, and
the note id (the hash of the signed note) are passed as arguments to the {\gloss{testimonyFor}} method
of the escrow contract. By implementing this method the contract conforms to the \gloss{witness} contract
 interface
(section \ref{sec:courtroom}). Given the witness contract, the escrow condition is implicitly defined
as whatever state makes the escrow witness give a positive testimony.

A note with an escrow field specified is called a \gloss{conditional bond} and
can represent a \gloss{service contract} with the escrow condition describing successful delivery.
In a real-life scenario, upon verification of an instance of service provision or purchase of a good,
the escrow acknowledges the delivery before releasing the funds.
This is implemented by the chequebook calling the escrow witness contract
to give a testimony. In case the condition is fully verifiable algorithmically in the VM,
the entire transaction remains within the closed system, there is no real-world liability and the transfer
is enforceable.

If no beneficiary is specified, a conditional note is essentially a \gloss{bounty}.
A bounty is meant to be published or broadcast to a set of known service providers.
Bounties will play a crucial role in certain types of service networks, discussed in section \ref{sec:wasp}.
Figure \ref{fig:taxonomy} summarises the various types of promissory notes.


\newcommand{\tick}{\checkmark}
\newcommand{\opt}{?}
\begin{center}
\begin{figure}
\begin{center}
\begin{tabular}{|l|r||c|c|c|c|c|c|c|}
\hline
note & fields
& swap cycle index
& amount
& beneficiary
& escrow
& valid from
& valid until
& remark
\\
\cline{2-9}

type & type 
& int256
& int256
& address
& address
& int256
& int256
& byte32
\\
\hline
\hline
\multicolumn{2}{|l||}{cheque}   & \tick & \tick & \tick & & & \opt& \opt
\\
\multicolumn{2}{|l||}{authorisation} &  & \tick & \tick & & & \opt& \opt
\\
\multicolumn{2}{|l||}{bond} & \tick & \tick & \tick & & \tick & \opt& \opt
\\
\multicolumn{2}{|l||}{conditional bond} &  & \tick & \tick & \tick & \tick & \opt& \opt
\\
\multicolumn{2}{|l||}{bounty} & \tick &  \tick & & \tick & \tick & \opt& \opt
\\
\multicolumn{2}{|l||}{soft channel deposit} &  \tick & \tick & & & && \opt
\\
\hline
\end{tabular}
\end{center}
\caption{Taxonomy of promissory notes: '\tick' indicates a mandatory field, types show the corresponding solidity type to encode in the ABI. '?' indicates optional field.}
\label{fig:taxonomy}
\end{figure}
\end{center}


% \subsection{Secure escrow and liquidity}

\subsection{Conditional bond, invoice, and cheque}

Let us assume that node A issues a conditional note (or bounty) to B with expiry at time T.
T represents the earliest time that A can consider the note unfulfilled (the service undelivered), before
that we say that the note is \emph{active}.

If B fulfills the condition, it notifies A of successful delivery
by sending an \gloss{invoice} containing the hash of the note and the current cumulative balance they want the
amount to be added to. The invoice is supposed to represent the balance at delivery, and serves to
indicate that the subsequent cheque will be the one to pay the outstanding amount for the note.
As a response A is expected to send a cheque with an updated channel balance reflecting the
payment of the invoice (the amount in the conditional note is added to the cumulative total).
If A refuses to do this, B can send the conditional note in a transaction
to  the contract. When the witness validates the delivery condition, and the testimony is
positive, the amount goes to escrow and a grace period starts.
During the grace period, A can settle the claim by sending in the appropriate cheque.

If the note condition does not check out, B's challenge will cost them the transaction.
Even if it does, they won't gain anything by the challenge if they did receive the
cheque from A since they still needed to send the proof in a transaction.
Therefore B is disincentived to initiate frivolous challenges.
Conversely, A is incentivised to send the cheque to B after it receives the invoice,
otherwise it is A that needs to pay the transaction cost of sending in the cheque upon B's correct challenge.
We therefore conclude that the optimal behaviour for A and B is offchain exchange of invoice and cheque.

\subsection{Soft channel deposits}
A nonmaturing cheque is a deposit locked up as collateral to secure varying balance.
The total value of these deposits serve as guaranteed collateral for any debt and
therefore conceptually equivalent to a channel deposit.
In the following we describe a construct which gives 100$\%$ guarantee of solvency
on outstanding conditional bonds without explicitly assigning deposits to channels on chain.%
%
\footnote{In the on-chain case channel deposits are explicitly stored in the contract, therefore overspending
(using the amount to collateralise multiple creditors) is impossible.}

Let us assume A and B both maintain an ordered list of active conditional notes issued by A.
Each time A issues a conditional note or pays for a fulfilled one or one expires, the list is updated.
The hashes of active notes in order of issuance is organised in a swarm tree, the
root hash of which is signed by B and passed to A together with a so called
\gloss{soft channel deposit claim}. This claim constitutes an acknowledment of
the outstanding liabilities of A towards B. Assume further that there exist a notion of \gloss{epoch},
a fixed settlement period at the end of which B needs to sign off on the total sum of active
outstanding conditional notes issued by A to B.
Formally, soft channel deposit claim is a note with the following fields:

\begin{itemize}
  \item A's contract address
  \item the total sum of all active outstanding conditional notes
  \item the epoch index
\end{itemize}

With each epoch, B signs the note and sends it to A.
Peer A can verify if the soft claim is correct and terminate dealings if not. In such a case soft claim of
the last epoch is taken, whereby A cancels its liability to the conditional notes issued since
the last epoch.
B is incentivised to send the correct soft claim if they want business with A fulfilling their
conditional notes.

After A receives soft channel deposit claims from all peers for the epoch, the claims are
collected in a list (ordered according to the peer index of the beneficiary in A's swap contract).
A signs the swarm hash of the (concatenated) list and sends it alongside the list
in a construct called a \gloss{soft channel deposit allocation table} to each peer.
Upon receiving the soft channel deposit allocation table, B verifies that
(1) the total sum of channel deposits allocated is no greater than the global deposit and
(2) the amount dedicated to B is no less than the sum of all outstanding active
conditional notes issued by A to B.
(3) each active peer in A's swap contract has a corresponding claim for the current epoch and the signature is valid.
This process in illustrated in figure \ref{fig:softchanneldeposit}


\begin{center}
\begin{figure}
\begin{center}
\begin{tikzpicture}
\end{tikzpicture}
\end{center}
\caption{Soft channel deposit}
\label{fig:softchanneldeposit}
\end{figure}
\end{center}




At any point in time, soft channel deposit claims can be consolidated to actual
channel deposits.
The soft channel deposit claim is sent in with the inclusion proof of the claim against the root hash of the
current channel deposit allocation table as a transaction to the
chequebook contract. Upon receiving and validating the claim (signature, resource and epoch verified),
the contract simply reallocates the claimed amount from the global deposit to the channel.
If each peer does this, the global deposit is reduced with the total of soft channel
deposits.%
%
\footnote{To save all peers the trouble of sending inclusion proofs, when A initiates withdrawal from
their global deposit, they need to submit current allocation table starting a grace period during which
creditors are invited to challenge the allocation by presenting a contradicting claim.}

Once the channel deposit (of A towards B) is secured on chain, all the outstanding conditional notes
issued to B are guaranteed to be redeemable in the standard ways.
If a peer is found to issue contradictory channel claims for the same epoch, they relinquish
their right to any claim. For any third party this entails that if a peer's claim is
included in the allocation table, the maximum they are entitled to redeem is limited to:
(1) the sum in the claim if they signed a correct unique claim or
(2) zero if they illegally signed multiple claims for the same epoch.
Futhermore, the allocation table is exhaustive, therefore each
peer signed their claim and no peer without a channel deposit are allowed to have a claim. 
From this, third parties can also conclude that the sum of all claims in the
allocation table is the maximum total deposit that can be consolidated as channel deposits.
In order to secure full liability, it is stipulated in the validity criteria of allocation tables, that the sum of allocations do not exceed the global soft channel deposit.

If the soft channel deposit allocation table is valid,
we can with complete certainty know that the global deposit in A's contract
 could cover all outstanding conditional notes handed to B even if all peers were to redeem all of their outstanding notes (e.g., by satisfying A's conditional bond).
Practically this means then that, after receiving a valid allocation table for the epoch from A,
B has no risk of insolvency when dealing with A's conditional notes.
To insure a completely risk-free flow of conditional notes, the peers only  need to make sure that the total of their outstanding nodes do not exceed the sum of the current soft channel  deposit and the on-chain channel  deposit. 
In fact nodes reallocate soft channel deposits to channels where they suspect that in the following epochs the total outstanding amount from conditional bonds and bounties will increase beyond what the channel deposit can cover and deallocate away from the channel if they are not expected to.
Therefore in a way, hard channel deposits play the role of the payment  threshold in simple swap, whereas soft channel deposits serve are somewhat analogous to cheques or waivers for service-specific collateral against issued service requests. 

In sum, using soft channel deposits enables the chequebook owner to allocate and reallocate funds
as channel deposits in a fairly flexible way without blockchain transaction costs,
yet provide $100\%$ solvency guarantees on all active conditional bonds and bounties to their peers.


\section{Service guarantees}
\label{sec:courtroom}

In the previous section we introduced tools to compensate service providers.
While rewards are paid out only if delivery is successful,
such positive incentivisation may be insufficient if
explicit guarantees of future delivery are required.

In this section we describe a system of service contracts and dispute resolution.
Service contracts allow providers (or a set of providers)
to offer quality and/or delivery guarantees to customers.
First we describe how to give service guarantees (swear), then discuss how they can be enforced (swindle).
Finally we link together the three contracts by showing how 


\subsection{Giving service guarantees}

Without loss of generality, we can conceptualise a generic service as described by a game contract
on the blockchain (see later in \ref{sec:swindle}).


Nodes can commit to providing a service by signing against the game contract
either in a transaction or issuing a signed note offchain.
By committing to the game contract  providers can be challenged if they don't comply with the rules.

Litigation on the other hand, allows customers to initiate an on-chain court procedure
in case they suspect foul play. Such accountability is
crucial for the design of scalable decentralised service economies.

We will describe the trial process for dispute
resolution that first evaluates the evidence against the accused provider.
The verification is the same as the one used in the process of sanctioning outpayments,
but once a provider is proven guilty by the court on the grounds of
conditions specified in the service contract, various punitive measures will be
automatically enforced. In most cases, this comprises losing some deposit that
provider previously locked up as collateral to back their promise.%
%
\footnote{Instead of or in addition to losing their deposits, nodes would also
suffer loss of reputation. If any demonstrated violation of terms is
recorded on the public blockchain, users can expect clean histories as a measure
of reputation.}
%
By registering on a service contract and putting up a deposit if required, providers
\emph{swear} to play by the rules.
This deposit is locked up and used later as compensatory insurance transferred to the
customer, redistributed or burnt.

\subsection{Challening a service contract}
label{sec:swindle}

If a service provider is suspected of non-compliance, they can be challenged
by opening a case with the swear contract analogous to filing a case and have it 
trialled in the courtroom.
An abstract trial is composed of stages of litigation, at each stage
the court procedure calls witnesses and, depending on their testimony,
advances the trial into the next stage. Witnesses can refuse testimony
if evidence is not (yet) available in which case the trial
is paused until the grace period allowed to submit evidence is over.
Eventually the trial concludes with a guilty or not guilty verdict followed
by automatically enforced punitive measures in the former case or
compensation to the accused in the latter.

The specific service contract describes the rules of the service
by assigning particular expert witnesses to trial stages. These witnesses
evaluate evidence submitted to them in relation to the case
and give testimony if asked by the judge.
The request--response process between the judge and the witnesses can
thus be standardized
even though they each may require different data to be submitted to them as evidence.

To implement such an abstract dispute resolution system
the trial is described by a finite state automaton, the states of which correspond
to stages of litigation and
the transitions are labeled by various outcomes of evaluating evidence submitted
to the respective expert witness associated with the stage. A witness
is a smart contract that implements the $\mathit{testimonyFor}$ function which takes
as arguments the provider address, the plaintiff address, and the note id (the hash of the signed note)
representing the service request.

The \gloss{swindle} contract orchestrates the transition through the stages calling the witness contracts,
handles grace periods to control the deadline for submitting evidence (challenges or their refutations) to
eventually reach a guilty/non-guilty verdict on the grounds of witness testimonies.
In case of a guilty verdict, the deposit sworn on is forfeited and the peer's registration is
terminated. 

\begin{center}
\begin{figure}
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2c m,
                    semithick]
  \tikzstyle{witness}=[fill=orange!50,draw]
  % \tikzstyle{every state}=[fill=gray!10,draw]

  \node[initial,state] (S)                    {$S$};
  \node[state,witness]         (W0_1) [above right of=S] {$w_0$};
  \node[state,witness]         (W0_2) [below right of=S] {$w_0$};
  \node[state,fill=green!60]         (N/G) [below right of=W0_1] {$N/G$};
  \node[state,witness]         (W1) [above right of=N/G] {$w_1$};
  \node[state,witness]         (W2) [below right of=N/G] {$w_2$};
  \node[state,witness]         (W3) [below right of=W1] {$w_3$};
  \node[state,fill=red!60]         (G) [right of=W3]       {$G$};

  \path (S) edge   node {$A_0$} (W0_1)
            edge   node {$A_1$} (W0_2)
        (W0_1) edge [loop above] node {n/a} (W0_1)
            edge [red,thick]             node {T} (W1)
            edge [green,thick]             node {F} (N/G)
        (W0_2) edge [loop below] node {n/a} (W0_2)
            edge [red,thick]             node {T} (W2)
            edge [green,thick]             node {F} (N/G)
        (W1) edge [loop above] node {n/a} (W1)
            edge [red,thick]             node {T} (W3)
            edge [green,thick]             node {F} (N/G)
        (W2) edge [loop below] node {n/a} (W2)
            edge  [red,thick]            node {T} (W3)
            edge  [green,thick]            node {F} (N/G)
        (N/G) edge              node {*} (S)
        (W3) edge [loop below] node {n/a} (W3)
            edge  [green,thick]            node {F} (N/G)
            edge [red,thick]  node {T} (G);
\end{tikzpicture}
\end{center}
\caption{Trial stages represented as a finite state automaton describing a service contract.
Upon receiving an accusation ($A_0$ or $A_1$) in a transaction, the case contract moves to the first litigation state.
The orange circles represent states where a witness contract is called, the following state depends on
the outcome of the witness testimony (the return value of the $\mathit{testimonyFor}$ function call).
The other nodes call the internal $\mathit{process}$ function: to pay compensation if the challenge is refuted (N/G) or enforce
the sentence in case of a guilty verdict (G).}
\label{fig:servicecontract}
\end{figure}
\end{center}

\subsection{Enforcing a guilty verdict}

When a guilty sentence is reached, the swindle contract calls back to the swear contract to enforce the forfeiture of the game deposit. The swear contract act as executor of the sentence, in a way similar to how a court order is observed by the agencies in a position to execute.  

The contract that handles the deposits and registers which node plays which game is called \gloss{swear}.
The swear contract is a registry from identities to game contracts.%
%
\footnote{One can imagine not completely open swear registries which curate a whitelist of safe or recommended games. Similarly to an appstore, these contracts could catalogue service games.}
%
An entry is created if provider signs off on a service game contract in an act of commitment. Essentially, the swear contract only needs to record how much deposit each commitment promised and let the swap channel handle the deposit.
The swear contract can  ask the swap if the provider's deposits exceed the amount dedicated as  swear deposits. This is simply implemented by allocating appropriate amount as channel deposit with the swear contract as beneficiary.
Commitments are implemented 


\section{Service networks}

In this section we describe how the tools for peer-to-peer accounting and data exchange can
be used to drive the incentives for distributed digital services.
Assume that a set of nodes form a network that provides a decentralised service.
Insured chunk storage in swarm, arbitrary remote payments or database insertion are examples of such services.
A \gloss{service task} is defined as an instance of service provision. Storing a particular chunk, paying
an amount to another node or inserting an entry to an index are examples of tasks of the respective network
service.

In what follows we will work with the assumption that the participating nodes in a service network are
connected in a \gloss{kademlia topology} and can relay messages to other nodes using kademlia deterministic routing
based on direct devp2p transport layer for each hop. In other words service networks are composed of a subset
of nodes within swarm.

Scalability of
swap channels is based on the premise that directly connected nodes engage in long-term repeated
dealings and can afford setting up contracts on the blockchain to secure their interaction.%
%
\footnote{Given the semipermanent connections of the TCP based kademlia of swarm, peers interact with
$O(log(n))$ peers where $n$ is the number of nodes in the network.}
%
Service networks enable \gloss{indirect transactions} by relaying tasks and deliveries using
swap-channel transactions on every hop.
This makes it possible to preserve the scalability and security
of swap, yet extend the scope of transactions both in terms of
frequency and reach, i.e., enabling \emph{ad-hoc one-off interactions between any two nodes}.
Service networks with global provision guarantees further improve the scope by
offering guaranteed market making and delivery in a direct immediately settling
swap transaction. As a result non-participating users can just \emph{request and disappear}.

\subsection{Incentivisation for relaying}

Let's assume that nodes A,B,C,D are participant peers of a service network such that
A-B, B-C and C-D are direct connections with a swap channel.
Assume further that A intends to do some ad-hoc one-off business with D. To this end
 A issues a conditional bond specifying an escrow
condition that some data be obtained from D constituting the proof of delivery of the task.

A then sends the conditional bond to B as beneficiary, B receives the conditional bond
and issues the same bond
only this time with C as beneficiary. C is directly connected to D, so
it just relays the same to D who issues a receipt (or takeover proof).
Each of these steps is implemented as swaps of conditional notes. The moment C receives
the receipt, it is incentivised to pass it back to B as an invoice to prompt
settlement. The same is true for B and any number of intermediate relaying nodes
(see figure \ref{fig:swapchannelnetwork}).

\begin{center}
\begin{figure}
\begin{center}
\end{center}
\caption{Swap channel network: peer to peer network of nodes with semipermanent TCP connections organised in
a kademlia topology. Given nodes have an associated identity owning a chequebook contract,
each live connection defines a swap channel}
\label{fig:swapchannelnetwork}
\end{figure}
\end{center}

In general, we define an \emph{indirect transaction} as a chain of swaps between directly connected
peers. The success of a such indirect transactions between two nodes is dependent on whether and
how such a chain can be found. Our assumption is that the nodes have semipermanent connectivity
and form a network topology where routing between any two nodes is guaranteed, e.g., kademlia. As a result, we can assume that as long as all nodes on the chain have a healthy kademlia connectivity, the prerequisite for finding the route is satisfied.

In order to incentivise relaying nodes to take part in such a network,
a transaction fee for every hop needs to be introduced.  We stipulate that the transaction fee
for one swap is proportional to the logarighmic distance that the hop spans.
As a consequence, the simple rational strategy to maximise profit will incentivise nodes to find the
closest node when relaying as well as maintain a healthy connectivity that is the
prerequisite for successful routing.
Furthermore, the entire transaction fee can be precalculated as proportional
to the distance between sender and remote beneficiary and therefore can be offered in advance
when issuing the conditional bond.

This construct is
equivalent to message relaying with \gloss{certified delivery}, except that nodes are required to have
funds to cover the amount of the conditional bond.
For live connections in a service network to be operational,
parties agree to always having in-channel capacity in the amount of X.
With soft channel deposits, such throughput restrictions can easily
be relaxed and adjusted even on an on-demand basis.

In addition to swap channels, connected nodes operate \gloss{provable data exchange}.
Assume that two nodes participate in a particular service that involve
relaying objects (such as requests and responses).
The content addresses (swarm hash) of consecutive objects
sent one direction constitute a \emph{data stream}.
Both peers save this stream to swarm and maintain an index mapping the hashes to offsets.
The upstream peer (sender) calculates the swarm hash of this index and periodically
signs it against the current blockheight or timestamp as well as the data stream identitfier.
This \gloss{handover state} is periodically sent to the downstream peer (receiver)
who verifies it and preserves it until the next one.
The downstream peer periodically countersigns the handover state together with an initial
offset or timestamp. This \gloss{takeover state} is then sent to the upstream peer.
For instance, the handover state obtained from the upstream peer can be used to prove to third parties
that an object X was handed over to the downstream peer. This can be done by
giving an inclusion proof of the hash of X.%
%
\footnote{Upstream peer can be challenged to give an inclusion proof.}

On top of the rewards peers get for relaying, we can introduce additional
incentives to guarantee that messages reach the recipient.
We can assume that relaying nodes register on a service contract they promise to relay messages in a data stream
towards the recipient.
If nodes have a stake to lose, punitive measures can be imposed on nodes that fail or refuse to relay messages in the data stream.

Take our earlier example of A sending a message to remote node D, and assume that
B, C, and D are all registered relaying nodes that are online. If there is reason
to believe that the message did not reach D, A can challenge B by simply providing
the takeover proof for the message. B can defend itself by providing takeover proof from C,
thereby shifting the blame to C for blocking the delivery. C in turn can show takeover proof
from D to refute the challenge. It can also happen that C indeed did not forward the message
because there was no node closer to D among its peers. But this means that
D is a nearest neighbour of C, in which case D should have been connected to C.
Therefore D can be challenged to prove that it was connected to C. D can respond to the challenge
by showing handover state obtained from C dated after the message delivery deadline. This in turn is
a challenge to C to show the inclusion proof of the message against the handover state.
This pattern is called \gloss{finger pointing} and constitutes the investigative part
of litigation which results in identifying the node
ultimately responsible for failed delivery by not relaying.
Finger pointing essentially implements \emph{guaranteed delivery}.

\subsection{Uniform resource allocation and market making}

In the previous section we just assumed that A knew about D (from an independent source).
In case there are other nodes as well that can in theory perform the same task,
a bounty is sent to potentially multiple addresses of candidate providers
and an implicit market making mechanism is obtained by certified delivery.

Assume the tasks of a service network can be provided by any participating node using
the same amount of resources. Given a network of willing providers, a system can be designed
called \gloss{global resource allocation by network topology (GRANT)}
such that tasks are distributed more or less uniformly across the network.

For instance, this is the case with storage in swarm:
each task of storage provision involves storing a fixed-size chunk of data.
We index the chunks with their content address (swarm hash) and allocate the storage task
to nodes whose address is closest to the chunk address.
Since both nodes and chunks are uniformly distributed in the same address space,
this strategy implements uniform load balancing. We can generalise this allocation
strategy for any task if requirements
are uniform across tasks by simply indexing the task requests with their hash.

When a service user issues a bounty to request a service task, the bounty
is sent towards the task's address using kademlia routing.
The node responsible of servicing the task is dynamically defined as the closest node at any point in time.
If hops use provable data streams, the incentives can make sure that the request (task bounty note) reaches the appropriate nodes and thereby are granted the opportunity to deliver the task.

For continuous services such as chunk storage, this means that as nodes leave
and join the network, the node responsible for a task can change over time.
With data exchange proofs however, we can enforce that nodes synchronise historical
task requests and therefore the allocation can be taken for granted, i.e., the network
can perform dynamic load-balancing of previously submitted future tasks even though
the network is changing.

In order to benefit from the allocated tasks by cashing the bounties on delivery, the distribution
should be incentivised. In particular relaying nodes are not supposed to withhold
tasks in hope of cashing the bounty themselves.
To guarantee that downstream peers do get forwarded all the tasks and bounties,
upstream peers can be challenged when they cash a bounty:
if there is a valid handover proof of connection (synchronisation)
for the relevant period after the bond was issued, upstream peer can be challenged
for not relaying it (but withholding). Conversely, the bounty outpayment can be challenged
if the candidate provider is not the closest node to the task, i.e., a downstream peer closer to
the task address can show connectivity during the relevant period. Withholding if proven could
result in the same punitive measure as failing to deliver.


Service nodes that are capable of staying online can choose to register
and put up a deposit as collateral.
One consequence of GRANT is that for each task, there is a node (or set of neighbouring nodes)
that is responsible for delivering the task and can ultimately be held liable
for non-delivery. Using the swindle scheme for litigation, if proven guilty a node's
collateral is forfeited.
Since individual punitive measures are a very
effective incentive, service guarantees can be given independent of the
positive incentivisation (the reward for delivery implicit in the bounty).%
%
\footnote{Since the amount of tasks (and therefore capacity requirements) are roughly uniform for each
participant node, catastrophic failure of an entire node can cause limited damage.
Since the required deposit is meant to collateralise this risk, it is reasonable to
set it to a fixed amount across all provider nodes.}

When the original issuer of the task request receives the receipt for its bounty (takeover proof) from its immediate peer,
they have all that is needed to start finger pointing after the deadline for the service task passed. In other words, service users have \emph{instant guarantees} that the service will be provided for the task they request, even though it is unknown at the time by which node.

This type of service network is called \gloss{warranted automatic service provision (WASP)} network.
Since one can thus obtain instant enforcable service guarantees 
in one swap exchange, WASP networks allow users to \gloss{request and disappear}. Applying this scheme to swarm insured storage, given a WASP network of storage nodes, swarm users can \emph{upload and disappear}.

\section{Pricing in service networks}

\subsection{Reverse auction for competitive bounties}

\subsection{Signalling capacity overload}
\subsection{Service networks for stablecoins}

\cite{btcmicro2014}
\cite{decker2015fast}
\cite{poon2015bitcoin}  %lightnening
\cite{prihodko2016flare} % routing in lightening
\cite{tremback2015universal}  %paymentchannels
\cite{bonneau2014mixcoin} % anonimity
\cite{ethersphere2016sw3}
\cite{ethersphere2016smash}
\cite{maymounkov2002kademlia}
\cite{heep2010r}
\cite{malavolta2017concurrency}
\cite{chiesa2017decentralized}
\cite{heilman2016tumblebit}
\cite{green2016bolt}
\cite{miller2017sprites}
\cite{mcdonald2017payment}
\cite{diferrante2017payment}

\bibliography{./refs.bib}
\appendix
\section{Swap contract}
\section{Swear and swindle contract}
\section{Swarm storage insurance}
\section{Scalable node-to-node payments}
\printglossary

\end{document}
